#!/bin/sh






# customized items of package
if [ -z "$SYNOPKG_PKGNAME" ]; then
	# prior DSM 3.2, start script will be run without environment variable
	#  at boot time, thus we need a workaround to gather name and version info
	PACKAGE_NAME="DownloadStation"
	PACKAGE_VER=`get_key_value "/var/packages/${PACKAGE_NAME}/INFO" "version"`
else
	PACKAGE_NAME=$SYNOPKG_PKGNAME
	PACKAGE_VER=$SYNOPKG_PKGVER
fi


SCRIPTSPATH="/var/packages/${PACKAGE_NAME}/target/scripts"
APP_PATH="/usr/syno/synoman/webman/3rdparty/$PACKAGE_NAME"
SYNO_SERVICE_TOOL="/usr/syno/sbin/synoservice"



pkg_get_dsm_version() {
	local version_file="/etc.defaults/VERSION"

	if [ ! -f "$version_file" ]; then
		echo "pkg_get_dsm_version: can not find version file '$version_file'"
		return 1
	fi
	local buildnumber=`grep -s ^buildnumber ${version_file} | head -1 | awk -F \" '{print $2}' | sed 's/ //g'`
	echo ${buildnumber}
}

DSM_BUILD_NUM=$(pkg_get_dsm_version)






PACKAGE_DIR="/var/packages/DownloadStation"
BIN_PATH="/var/packages/playitGG/target/bin/playit-linux"
PID_FILE="/volume1/1/playitGG/playit.pid"
LOG_FILE="/volume1/1/playitGG/LOG/playit.log"


# create @download folder and service link
	${SYNO_SERVICE_TOOL} --setshare download





# Tworzenie folderu w /volume1/1/playitGG, jeśli nie istnieje
mkdir -p /volume1/1/playitGG
mkdir -p "$(dirname "$LOG_FILE")"

# Logowanie do pliku (wszystkie stdout i stderr trafiają do LOG_FILE)
exec > "$LOG_FILE" 2>&1

echo "------------------------------------------------"
echo "$(date '+%Y-%m-%d %H:%M:%S') - Uruchomiono skrypt zarządzania usługą playit.gg"
echo "------------------------------------------------"

# Funkcja uruchamiająca aplikację jako demon
start_daemon() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - Starting playit.gg..."
    nohup "$BIN_PATH" >> "$LOG_FILE" 2>&1 &
    if [ $? -eq 0 ]; then
        echo $! > "$PID_FILE"
        echo "$(date '+%Y-%m-%d %H:%M:%S') - playit.gg started with PID $(cat "$PID_FILE")."
    else
        echo "$(date '+%Y-%m-%d %H:%M:%S') - Failed to start playit.gg."
    fi
}

# Funkcja zatrzymująca aplikację
stop_daemon() {
    if [ -f "$PID_FILE" ]; then
        PID=$(cat "$PID_FILE")
        echo "$(date '+%Y-%m-%d %H:%M:%S') - Stopping playit.gg with PID $PID..."
        kill "$PID" && rm -f "$PID_FILE"
        echo "$(date '+%Y-%m-%d %H:%M:%S') - playit.gg stopped."
    else
        echo "$(date '+%Y-%m-%d %H:%M:%S') - playit.gg is not running."
    fi
}

# Funkcja sprawdzająca status aplikacji
status_daemon() {
    if pgrep -f "$BIN_PATH" > /dev/null; then
        echo "$(date '+%Y-%m-%d %H:%M:%S') - playit.gg is running."
        exit 0
    else
        echo "$(date '+%Y-%m-%d %H:%M:%S') - playit.gg is not running."
        exit 1
    fi
}

# Sprawdzanie argumentów i wywoływanie odpowiednich funkcji
case "$1" in
    start)
        start_daemon ;;
    stop)
        stop_daemon ;;
    status)
        status_daemon ;;
    restart)
        stop_daemon
        start_daemon ;;
    *)
        echo "Usage: $0 {start|stop|restart|status}" ;;
esac

exit 0


