#!/bin/sh

### Global Variables
### ---------------

# Package information
PACKAGE="playitGG"
INSTALL_DIR="${SYNOPKG_PKGDEST}"
VAR_DIR="${SYNOPKG_PKGDEST}/var"
TMP_DIR="${SYNOPKG_TEMP_LOGDIR}"
CONFIG_DIR="${VAR_DIR}/config"
DATA_DIR="${VAR_DIR}/data"

# User and group management 
USER="playitGG"
GROUP="playitGG"
EFF_USER="sc-playitGG"
EFF_GROUP="sc-playitGG"

# Service settings
SERVICE_NAME="playitGG"
PID_FILE="${VAR_DIR}/${SERVICE_NAME}.pid"
LOG_FILE="${VAR_DIR}/logs/${SERVICE_NAME}.log"
LOG_DIR="${VAR_DIR}/logs"
SERVICE_PORT="8080" # Default service port if applicable

# Configuration files
CONFIG_FILE="${CONFIG_DIR}/config.yml"
TOKEN_FILE="${CONFIG_DIR}/token"
SECRET_KEY_FILE="${CONFIG_DIR}/secret_key"

### Environment validation
### ---------------------

if [ -z "${SYNOPKG_PKGNAME}" ] || [ -z "${SYNOPKG_DSM_VERSION_MAJOR}" ]; then
  echo "Error: Environment variables are not set." 1>&2
  echo "Please run me using synopkg instead. Example: \"synopkg start [packagename]\"" 1>&2
  exit 1
fi

# Compatibility with DSM7
SYNOPKG_PKGVAR="${VAR_DIR}"

### Helper Functions
### ---------------

# Logging function 
install_log() {
    local _level="$1"
    local _msg="$2"
    local _timestamp
    _timestamp=$(date "+%Y-%m-%d %H:%M:%S")
    
    # Create log directory if it doesn't exist
    [ -d "${LOG_DIR}" ] || mkdir -p "${LOG_DIR}"
    
    # Output to log file and stdout/stderr
    case "${_level}" in
        ERROR)
            echo "[${_timestamp}] [ERROR] ${_msg}" >> "${LOG_FILE}" 2>&1
            echo "[${_timestamp}] [ERROR] ${_msg}" 1>&2
            ;;
        WARNING)
            echo "[${_timestamp}] [WARNING] ${_msg}" >> "${LOG_FILE}" 2>&1
            echo "[${_timestamp}] [WARNING] ${_msg}" 1>&2
            ;;
        INFO)
            echo "[${_timestamp}] [INFO] ${_msg}" >> "${LOG_FILE}" 2>&1
            echo "[${_timestamp}] [INFO] ${_msg}"
            ;;
        DEBUG)
            if [ "${DEBUG_MODE}" = "true" ]; then
                echo "[${_timestamp}] [DEBUG] ${_msg}" >> "${LOG_FILE}" 2>&1
                echo "[${_timestamp}] [DEBUG] ${_msg}"
            fi
            ;;
        *)
            echo "[${_timestamp}] ${_msg}" >> "${LOG_FILE}" 2>&1
            echo "[${_timestamp}] ${_msg}"
            ;;
    esac
}

# Directory creation with proper permissions
ensure_dir() {
    local _dir="$1"
    local _owner="${2:-$USER:$GROUP}"
    local _perms="${3:-0755}"
    
    if [ ! -d "${_dir}" ]; then
        install_log "INFO" "Creating directory ${_dir}"
        mkdir -p "${_dir}" || { install_log "ERROR" "Failed to create directory ${_dir}"; return 1; }
    fi
    
    # Set permissions
    chmod "${_perms}" "${_dir}" || { install_log "ERROR" "Failed to set permissions on ${_dir}"; return 1; }
    
    # Set ownership if not running as root, use syno user/group commands
    if [ "$(id -u)" = "0" ]; then
        chown "${_owner}" "${_dir}" || { install_log "ERROR" "Failed to set ownership on ${_dir}"; return 1; }
    fi
    
    return 0
}

# Set file/directory permissions
set_permissions() {
    local _path="$1"
    local _owner="${2:-$USER:$GROUP}"
    local _perms="${3:-0644}"
    
    install_log "INFO" "Setting permissions on ${_path} to ${_perms}, owner ${_owner}"
    
    # Check if path exists
    if [ ! -e "${_path}" ]; then
        install_log "ERROR" "Path ${_path} does not exist"
        return 1
    fi
    
    # Set permissions
    chmod "${_perms}" "${_path}" || { install_log "ERROR" "Failed to set permissions on ${_path}"; return 1; }
    
    # Set ownership if running as root
    if [ "$(id -u)" = "0" ]; then
        chown "${_owner}" "${_path}" || { install_log "ERROR" "Failed to set ownership on ${_path}"; return 1; }
    fi
    
    return 0
}

# User management (create/remove)
manage_service_user() {
    local _action="$1"
    
    case "${_action}" in
        create)
            # Create the user and group if they don't exist
            if [ "${SYNOPKG_DSM_VERSION_MAJOR}" -ge 7 ]; then
                # DSM 7+ uses built-in service users
                install_log "INFO" "Using DSM7+ service user ${EFF_USER}"
                return 0
            else
                # Create a system user for DSM 6
                synouser --get "${USER}" > /dev/null 2>&1 || \
                    synouser --add "${USER}" "${SYNOPKG_PKGNAME} service" 0 "" "" || \
                    { install_log "ERROR" "Failed to create user ${USER}"; return 1; }
                    
                # Add user to appropriate groups if needed
                # synogroup --member "users" "${USER}" || true
            fi
            ;;
        remove)
            # Only remove user if on DSM 6 and lower
            if [ "${SYNOPKG_DSM_VERSION_MAJOR}" -lt 7 ]; then
                # Check if user exists before trying to remove
                synouser --get "${USER}" > /dev/null 2>&1 && \
                    synouser --del "${USER}" || \
                    install_log "WARNING" "User ${USER} not found or could not be removed"
            fi
            ;;
        *)
            install_log "ERROR" "Invalid action '${_action}' for manage_service_user"
            return 1
            ;;
    esac
    
    return 0
}

# Generate or read secret key
get_secret_key() {
    # If secret key file exists, read it
    if [ -f "${SECRET_KEY_FILE}" ]; then
        cat "${SECRET_KEY_FILE}"
        return 0
    fi
    
    # Generate a new secret key and store it
    install_log "INFO" "Generating new secret key"
    ensure_dir "$(dirname "${SECRET_KEY_FILE}")" "${USER}:${GROUP}" "0700"
    
    # Generate a random 64-character hex string
    if command -v openssl > /dev/null 2>&1; then
        openssl rand -hex 32 > "${SECRET_KEY_FILE}" || \
            { install_log "ERROR" "Failed to generate secret key"; return 1; }
    else
        # Fallback if openssl is not available
        head -c 32 /dev/urandom | xxd -p > "${SECRET_KEY_FILE}" || \
            { install_log "ERROR" "Failed to generate secret key"; return 1; }
    fi
    
    set_permissions "${SECRET_KEY_FILE}" "${USER}:${GROUP}" "0600"
    cat "${SECRET_KEY_FILE}"
    return 0
}

### Package specific functions
### -------------------------

# Initialize package directories
initialize_directories() {
    # Create and set permissions for required directories
    ensure_dir "${VAR_DIR}" "${USER}:${GROUP}" "0755" || return 1
    ensure_dir "${CONFIG_DIR}" "${USER}:${GROUP}" "0755" || return 1
    ensure_dir "${DATA_DIR}" "${USER}:${GROUP}" "0755" || return 1
    ensure_dir "${LOG_DIR}" "${USER}:${GROUP}" "0755" || return 1
    
    return 0
}

# Service command preparation
prepare_service_command() {
    local _secret_key
    
    # Get or generate the secret key
    _secret_key=$(get_secret_key) || return 1
    
    # Construct service command with the secret key
    SERVICE_COMMAND="${INSTALL_DIR}/bin/playit-linux start --secret ${_secret_key}"
    
    # Service options
    SVC_BACKGROUND=y
    SVC_WRITE_PID=y
    
    return 0
}

### Service lifecycle hooks
### ----------------------

service_preinst() {
    initialize_directories || return 1
    install_log "INFO" "Pre-installation steps completed"
    return 0
}

service_postinst() {
    install_log "INFO" "Running post-installation steps"
    
    # Create service user
    manage_service_user "create" || return 1
    
    # Initialize directories with proper permissions
    initialize_directories || return 1
    
    # Process configuration files
    if [[ "${SYNOPKG_PKG_STATUS}" == "INSTALL" ]]; then
        if [ -e "${CONFIG_FILE}" ]; then
            # Populate config template
            install_log "INFO" "Updating configuration file from wizard values"
            sed -i -e "s|@token@|${wizard_playit_token:-}|g" "${CONFIG_FILE}" || \
                { install_log "ERROR" "Failed to update configuration file"; return 1; }
                
            install_log "INFO" "Configuration file populated"
        else
            install_log "WARNING" "Config file not found at ${CONFIG_FILE}"
            
            # Create a default configuration file if it doesn't exist
            install_log "INFO" "Creating default configuration file"
            cat > "${CONFIG_FILE}" << EOF
# PlayIt.GG Configuration
# Generated: $(date "+%Y-%m-%d %H:%M:%S")
token: "${wizard_playit_token:-}"
EOF
            set_permissions "${CONFIG_FILE}" "${USER}:${GROUP}" "0600"
        fi
    fi
    
    # Prepare service command
    prepare_service_command || return 1
    
    install_log "INFO" "Post-installation completed successfully"
    return 0
}

service_preuninst() {
    install_log "INFO" "Running pre-uninstallation steps"
    # Nothing specific needed here, but could add backup functionality
    return 0
}

service_postuninst() {
    install_log "INFO" "Running post-uninstallation steps"
    
    # Remove service user if appropriate
    manage_service_user "remove" || true
    
    install_log "INFO" "Post-uninstallation completed"
    return 0
}

service_preupgrade() {
    install_log "INFO" "Running pre-upgrade steps"
    
    # Create backup directory
    BACKUP_DIR="${TMP_DIR}/backup"
    ensure_dir "${BACKUP_DIR}" "root:root" "0755" || return 1
    
    # Backup configuration files
    install_log "INFO" "Backing up configuration files to ${BACKUP_DIR}"
    
    # Backup config.yml if it exists
    if [ -f "${CONFIG_FILE}" ]; then
        install_log "INFO" "Backing up config file: ${CONFIG_FILE}"
        cp -f "${CONFIG_FILE}" "${BACKUP_DIR}/config.yml" || { 
            install_log "ERROR" "Failed to backup config file"; 
            return 1; 
        }
    fi
    
    # Backup token file if it exists
    if [ -f "${TOKEN_FILE}" ]; then
        install_log "INFO" "Backing up token file: ${TOKEN_FILE}"
        cp -f "${TOKEN_FILE}" "${BACKUP_DIR}/token" || { 
            install_log "ERROR" "Failed to backup token file"; 
            return 1; 
        }
    fi
    
    # Backup secret key if it exists
    if [ -f "${SECRET_KEY_FILE}" ]; then
        install_log "INFO" "Backing up secret key: ${SECRET_KEY_FILE}"
        cp -f "${SECRET_KEY_FILE}" "${BACKUP_DIR}/secret_key" || {
            install_log "ERROR" "Failed to backup secret key file"; 
            return 1; 
        }
    fi
    
    # Backup any custom configurations or data if needed
    # For example, if you have custom user settings or data files
    if [ -d "${DATA_DIR}" ]; then
        install_log "INFO" "Backing up data directory: ${DATA_DIR}"
        cp -rf "${DATA_DIR}" "${BACKUP_DIR}/data" || {
            install_log "INFO" "No data directory to backup or failed to backup";
        }
    fi
    
    install_log "INFO" "Pre-upgrade backup completed successfully"
    return 0
}

service_postupgrade() {
    install_log "INFO" "Running post-upgrade steps"
    
    # Create service user (in case user management changed)
    manage_service_user "create" || return 1
    
    # Initialize directories with proper permissions
    initialize_directories || return 1
    
    # Define backup directory
    BACKUP_DIR="${TMP_DIR}/backup"
    
    if [ -d "${BACKUP_DIR}" ]; then
        install_log "INFO" "Restoring configuration from backup"
        
        # Restore config file if backup exists
        if [ -f "${BACKUP_DIR}/config.yml" ]; then
            install_log "INFO" "Restoring config file from backup"
            cp -f "${BACKUP_DIR}/config.yml" "${CONFIG_FILE}" || {
                install_log "ERROR" "Failed to restore config file";
            }
            set_permissions "${CONFIG_FILE}" "${USER}:${GROUP}" "0600"
        fi
        
        # Restore token file if backup exists
        if [ -f "${BACKUP_DIR}/token" ]; then
            install_log "INFO" "Restoring token file from backup"
            cp -f "${BACKUP_DIR}/token" "${TOKEN_FILE}" || {
                install_log "ERROR" "Failed to restore token file";
            }
            set_permissions "${TOKEN_FILE}" "${USER}:${GROUP}" "0600"
        fi
        
        # Restore secret key if backup exists
        if [ -f "${BACKUP_DIR}/secret_key" ]; then
            install_log "INFO" "Restoring secret key from backup"
            cp -f "${BACKUP_DIR}/secret_key" "${SECRET_KEY_FILE}" || {
                install_log "ERROR" "Failed to restore secret key";
            }
            set_permissions "${SECRET_KEY_FILE}" "${USER}:${GROUP}" "0600"
        fi
        
        # Restore data directory if backup exists
        if [ -d "${BACKUP_DIR}/data" ]; then
            install_log "INFO" "Restoring data directory from backup"
            cp -rf "${BACKUP_DIR}/data/"* "${DATA_DIR}/" || {
                install_log "WARNING" "Could not fully restore data directory";
            }
        fi
        
        # Clean up backup files after successful restoration
        rm -rf "${BACKUP_DIR}" || install_log "WARNING" "Could not remove backup directory"
    else
        install_log "WARNING" "No backup directory found at ${BACKUP_DIR}"
    fi
    
    # Merge any new default settings with existing configuration
    merge_configs || install_log "WARNING" "Could not merge configurations"
    
    # Prepare service command
    prepare_service_command || return 1
    
    install_log "INFO" "Post-upgrade completed successfully"
    return 0
}

# Helper function to merge old and new configurations
merge_configs() {
    install_log "INFO" "Checking for configuration updates"
    
    # If no config file exists, create a default one
    if [ ! -f "${CONFIG_FILE}" ]; then
        install_log "INFO" "No existing config found, creating default"
        cat > "${CONFIG_FILE}" << EOF
# PlayIt.GG Configuration
# Generated: $(date "+%Y-%m-%d %H:%M:%S")
# Default configuration created during upgrade
token: ""
EOF
        set_permissions "${CONFIG_FILE}" "${USER}:${GROUP}" "0600"
        return 0
    fi
    
    # Here you would add logic to merge any new configuration options
    # with existing ones, preserving user settings
    
    # Example: Add new configuration options that may not exist in older versions
    # This is just a placeholder and should be customized for your application
    if ! grep -q "log_level:" "${CONFIG_FILE}"; then
        install_log "INFO" "Adding new log_level configuration option"
        echo -e "\n# Added in upgrade\nlog_level: \"info\"" >> "${CONFIG_FILE}"
    fi
    
    # Example: Updating deprecated options
    # sed -i 's/old_option:/new_option:/g' "${CONFIG_FILE}"
    
    return 0
}
